{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang2057{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fmodern JetBrains Mono;}}
{\colortbl ;\red204\green120\blue50;\red169\green183\blue198;\red152\green118\blue170;\red104\green151\blue187;\red255\green198\blue109;\red106\green135\blue89;\red128\green128\blue128;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\ul\b\f0\fs22\lang9 ** Core Java Assignment5 **\par
\ulnone\b0\par
1.\par
\b Java Development Kit (JDK)\par
\b0\tab It is platform-dependent. \par
\tab As it has different OS platform versions for Windows, Linux, Mac, etc.\par
\b Java Runtime Environment (JRE)\par
\b0\tab It is platform-dependent.\par
\tab The JRE includes class libraries along with JVM and its supporting files.\par
\tab justification: in java we can use native libraries to execute the extra functionalities apart from the java standard library. so  they can be different for different platforms.\par
\tab In general, Java libraries are designed to be platform-independent,\par
\tab but it's important to keep in mind that some libraries and APIs may be specific to a particular operating system.\par
\b JVM(java virtual machine) => \par
\b0\tab  it is platform dependant.\par
\tab  it is designed to execute Java bytecode, which is a machine-independent representation of Java code. \par
\tab  the implementation of the JVM is specific to a particular operating system and hardware architecture, \par
\tab\tab\tab and must be installed and configured for each platform that a Java application will run on.\par
\par
Therefore I can say that JDK,JRE,JVM are all platform dependent as their performance may vary as per the platform\par
rather I can say that the byte code file is platform independent which can be executed on any platform.\par
\par
2.\par
Yes, it is possible to download the Java Runtime Environment (JRE) without the Java Development Kit (JDK). \par
The JRE is a standalone software package that includes the Java Virtual Machine (JVM), the Java Standard Library, and other components required to run Java applications. \par
The JRE is all that is required to run Java applications, but does not include the tools and libraries needed to develop Java applications.\par
\par
\par
=========================================================================\par
2.\par
JVM is the one that actually calls the main method present in a java code\par
Java applications are called WORA (Write Once Run Anywhere)\par
When we compile a .java file, .class files(contains byte-code) with the same class names present in .java file are generated by the Java compiler. This .class file goes into various steps when we run it. These steps together describe the whole JVM. \par
Class Loader Subsystem\par
\par
It is mainly responsible for three activities. \par
Loading\par
Linking\par
Initialization\par
\par
Loading: The Class loader reads the \ldblquote .class\rdblquote  file, generate the corresponding binary data and save it in the method area. \par
Linking: Performs verification, preparation, and (optionally) resolution. \par
Initialization: In this phase, all static variables are assigned with their values defined in the code and static block(if any)\par
Execution Engine \par
Execution engine executes the \ldblquote .class\rdblquote  (bytecode). \par
It reads the byte-code line by line, uses data and information present in various memory area and executes instructions.\par
\par
3.\par
\par
The bytecode file contains instructions that are executed by the JVM to perform the operations specified in the original Java source file. These instructions include:\par
Class definitions\par
Method definitions\par
Field definitions\par
Instructions for object creation\par
Instructions for performing arithmetic and logical operations\par
Instructions for control flow\par
Instructions for accessing class and instance variables\par
Instructions for invoking methods and constructors\par
The bytecode generated from a Java file is typically stored in a .class file, which can be executed by the JVM to run the program.\par
\par
4.\par
Access specifier and access modifier are terms that are used interchangeably in Java to refer to the level of access or visibility that is granted to members \par
(fields, methods, etc.) of a class.\par
An access specifier determines who can access the members of a class. Java provides three levels of access:\par
Public: Members marked as public can be accessed from anywhere in the code.\par
Private: Members marked as private can only be accessed within the class in which they are declared.\par
Protected: Members marked as protected can be accessed within the class in which they are declared, as well as any subclasses.\par
An access modifier, on the other hand, is a broader term that encompasses other types of restrictions that can be placed on members, such as final, static, \par
abstract, etc. These access modifiers can be used in combination with the access specifiers to further restrict the visibility and usage of the members.\par
So, to summarize:\par
Access specifier determines the visibility of members within the class and its subclasses.\par
Access modifier encompasses access specifiers and other restrictions that can be applied to members\par
5.\par
No, you cannot have multiple public static void main(String[] args) methods in a single class in Java. \par
The main method is the starting point of a Java program, and having multiple main methods in a single class would cause ambiguity and \par
make it unclear which method the Java Virtual Machine (JVM) should start executing.\par
If you want to run different code blocks in the same class, you can use methods other than main and call them from the main method, \par
or you can create multiple classes and have each one with its own main method.\par
6.\par
No, you cannot overload or override the public static void main(String[] args) method in Java. The main method is a special method that serves as the entry point \par
for a Java program, and it must have the exact signature specified above in order to be recognized by the Java Virtual Machine (JVM)\par
as the starting point for the program.\par
The method signature cannot be changed, and attempting to do so will result in a compile-time error.\par
Overloading and overriding are concepts related to polymorphism in object-oriented programming, and they apply to regular methods, but not to the main method.\par
\par
7.\par
No, you cannot write the main method as private, protected, or default in Java.The main method must be declared as public in order to be accessible from outside the class\par
, and to be recognized as the starting point of the Java program by the Java Virtual Machine (JVM).\par
The public access modifier on the main method allows it to be called from outside the class, including by the JVM when it starts executing the program. \par
If the main method is declared as private, protected, or default, it will not be accessible from outside the class and the JVM will not be able to find and \par
execute the method, causing the program to not run.\par
\u8203?\par
8.\par
 the main method must be declared as public in order to be executed by the Java Virtual Machine (JVM). The reason for this is that the JVM needs to be able to access the main method in order to start executing the program.\par
If you declare the main method as private, protected, or with default (package) access, the JVM will not be able to access it and the program will not run.\par
therefore the main method in Java must be declared as public in order to be executed by the JVM. You cannot declare it as private, protected, or with default (package) access.\par
\par
9.\par
In Java, the main method serves as the entry point for executing a program and it is required for a standalone Java application.\par
 However, if you want to run code without a main method, you can create an instance of a class and call its methods.\par
Ex.\par
class HelloWorld \{\par
  void sayHello() \{\par
    System.out.println("Hello World");\par
  \}\par
\}\par
\par
public class Main \{\par
  public static void main(String[] args) \{\par
    HelloWorld hello = new HelloWorld();\par
    hello.sayHello();\par
  \}\par
\}\tab\par
Therefore we can say that to run code without a main method in Java, you can create an instance of a class and call its methods from another class with a main method.\par
\par
10.\par
No, you cannot change the return type of the public static void main(String[] args) method in Java. \par
The main method must have a return type of void in order to be recognized by the Java Virtual Machine (JVM) as the entry point for a Java program.\par
The void return type indicates that the main method does not return a value. If you try to change the return type to a different data type, \par
such as int or String, the JVM will not be able to find and execute the method, causing the program to not run.\par
It's important to keep the signature of the main method as public static void main(String[] args) to ensure that it can be recognized and executed by the JVM \par
as the starting point for the program.\par
\par
\par
11.\par
strictfp is a Java keyword that is used to indicate that a method or a class is subject to the IEEE 754 standard for floating-point arithmetic. When you declare a method or a class as strictfp, the JVM will use the same rules for floating-point arithmetic across all platforms, ensuring that the results of floating-point operations are consistent and predictable regardless of the underlying hardware.\par
Ex:\par
strictfp double calculatePi() \par
\{  // code\par
\}\par
When you declare a method as strictfp, it guarantees that the result of the method's floating-point operations will be the same across all platforms. This can be useful for applications that require consistent and predictable results, such as financial and scientific applications.\par
\par
===========================================================================\par
\par
2.\par

\pard\box\brdrdash\brdrw0 \sa200\sl276\slmult1\cf1\f1\fs20 package \cf2 feb_week1\cf1 ;\line\line\line     class \cf2 Variables\{\line         \cf1 int \cf3 number3 \cf2 =\cf4 24\cf1 , \cf3 number4 \cf2 = \cf4 6\cf1 ;\line         static int \cf3\i result \cf1\i0 ;\line\line         public void \cf5 local_variable\cf2 ()\{\line             \cf1 int \cf2 number1 =\cf4 48\cf1 , \cf2 number2 = \cf4 6 \cf1 ;\line             \cf3\i result\cf2\i0 =number1+number2\cf1 ;\line             \cf2 System.\cf3\i out\cf2\i0 .println(\cf6 " access local variables :  " \cf2 + \cf3\i result\cf2\i0 )\cf1 ;\line         \cf2\}\line         \cf1 public void \cf5 global_variable\cf2 ()\{\line             \cf3\i result\cf2\i0 =\cf3 number3\cf2 +\cf3 number4\cf1 ;\line             \cf2 System.\cf3\i out\cf2\i0 .println(\cf6 " access global variables :  " \cf2 + \cf3\i result\cf2\i0 )\cf1 ;\line         \cf2\}\line         \cf1 public static void \cf5 static_variable\cf2 ()\{\line             \cf7 // result=number3+number4; can't access global variable (non static variable) in static method;\line             \cf2 System.\cf3\i out\cf2\i0 .println(\cf6 " static variables " \cf2 + \cf3\i result\cf2\i0 )\cf1 ;\line         \cf2\}\line\}\line\line\cf1 public class \cf2 day5_assignment5 \{\line     \cf1 public static void \cf5 main\cf2 (String[] args) \{\line         Variables variables =\cf1 new \cf2 Variables()\cf1 ;\line         \cf2 variables.local_variable()\cf1 ;\line         \cf2 variables.global_variable()\cf1 ;\line         \cf2 Variables.\i static_variable\i0 ()\cf1 ;\line\line\line     \cf2\}\}\line\par

\pard\sa200\sl276\slmult1\cf0\f0\fs22\par
===========================================================================\par
\par
3.\par

\pard\box\brdrdash\brdrw0 \sa200\sl276\slmult1\cf1\f1\fs20 package \cf2 feb_week1\cf1 ;\line\line  class \cf2 Addition\{\line     \cf1 public int \cf5 add\cf2 (\cf1 int \cf2 num1\cf1 ,int \cf2 num2)\{\line         \cf1 int \cf2 sum\cf1 ;\line         \cf2 sum=num1+num2\cf1 ;\line         return \cf2 sum\cf1 ;\line     \cf2\}\line\}\line\cf1 public class \cf2 DatatypeAddition \{\line     \cf1 public static void \cf5 main\cf2 (String[] args) \{\line         Addition addition=\cf1 new \cf2 Addition()\cf1 ;\line         \cf2 System.\cf3\i out\cf2\i0 .println(\cf6 "Addition is: "\cf2 + addition.add(\cf4 45\cf1 ,\cf4 77\cf2 ))\cf1 ;\line     \cf2\}\line\}\line\par
\f0\lang2057 ====================================================================================\par
\par
\par
}
 